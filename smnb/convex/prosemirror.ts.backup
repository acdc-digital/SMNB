// convex/prosemirror.ts
import { ProsemirrorSync } from "@convex-dev/prosemirror-sync";
import { components } from "./_generated/api";
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

const prosemirrorSync = new ProsemirrorSync(components.prosemirrorSync);

export const {
  getSnapshot,
  submitSnapshot,
  latestVersion,
  getSteps,
  submitSteps,
} = prosemirrorSync.syncApi({
  checkRead(_ctx, _id) {
    // For now, allow all reads - in production, add authentication checks
    // const user = await userFromAuth(ctx);
    // Add user authentication logic here
  },
  checkWrite(_ctx, _id) {
    // For now, allow all writes - in production, add authentication checks
    // const user = await userFromAuth(ctx);
    // Add user authentication logic here
  },
  async onSnapshot(ctx, id, snapshot, version) {
    // When a snapshot is created, save it to our editor_documents table
    console.log(`📸 Saving editor snapshot for document ${id}, version ${version}`);
    
    try {
      // Parse the ProseMirror JSON to extract text content
      const doc = JSON.parse(snapshot);
      const textContent = extractTextFromProsemirrorDoc(doc);
      const wordCount = textContent.trim().split(/\s+/).length;
      const characterCount = textContent.length;
      
      // Check if document already exists
      const existing = await ctx.db
        .query("editor_documents")
        .withIndex("by_document_id", (q) => q.eq("document_id", id))
        .unique();
      
      if (existing !== null) {
        // Update existing document
        // @ts-expect-error - Convex ID typing issue
        await ctx.db.patch(existing._id, {
          content_json: snapshot,
          content_text: textContent,
          version,
          word_count: wordCount,
          character_count: characterCount,
          updated_at: Date.now(),
        });
      } else {
        // Create new document
        await ctx.db.insert("editor_documents", {
          document_id: id,
          title: `Editor Document ${id}`,
          content_json: snapshot,
          content_text: textContent,
          version,
          word_count: wordCount,
          character_count: characterCount,
          status: "active",
          created_at: Date.now(),
          updated_at: Date.now(),
          generated_by_agent: true,
          source_posts: [],
        });
      }
      
      console.log(`✅ Saved editor document ${id}: ${wordCount} words, ${characterCount} characters`);
    } catch (error) {
      console.error(`❌ Failed to save editor snapshot:`, error);
    }
  },
});

// Helper function to extract text content from ProseMirror document
function extractTextFromProsemirrorDoc(doc: { content?: unknown[] }): string {
  if (!doc || !doc.content) return '';
  
  let text = '';
  
  function extractFromNode(node: { text?: string; content?: unknown[] }): void {
    if (node.text) {
      text += node.text;
    }
    if (node.content) {
      node.content.forEach((child) => extractFromNode(child as { text?: string; content?: unknown[] }));
    }
  }
  
  doc.content.forEach((child) => extractFromNode(child as { text?: string; content?: unknown[] }));
  return text;
}

// Query to get all editor documents
export const getEditorDocuments = query({
  args: {
    limit: v.optional(v.number()),
    status: v.optional(v.union(v.literal("draft"), v.literal("active"), v.literal("archived"))),
  },
  handler: async (ctx, args) => {
    if (args.status !== undefined) {
      return await ctx.db
        .query("editor_documents")
        // @ts-expect-error - Convex typing issue with optional union types
        .withIndex("by_status", (q) => q.eq("status", args.status))
        .order("desc")
        .take(args.limit ?? 50);
    }
    
    return await ctx.db
      .query("editor_documents")
      .order("desc")
      .take(args.limit ?? 50);
  },
});

// Query to get a specific editor document
export const getEditorDocument = query({
  args: { documentId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("editor_documents")
      .withIndex("by_document_id", (q) => q.eq("document_id", args.documentId))
      .first();
  },
});

// Mutation to update editor document metadata
export const updateEditorDocument = mutation({
  args: {
    documentId: v.string(),
    title: v.optional(v.string()),
    status: v.optional(v.union(v.literal("draft"), v.literal("active"), v.literal("archived"))),
    sourcePosts: v.optional(v.array(v.string())),
    generationMetadata: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const document = await ctx.db
      .query("editor_documents")
      .withIndex("by_document_id", (q) => q.eq("document_id", args.documentId))
      .first();
    
    if (!document) {
      throw new Error(`Editor document ${args.documentId} not found`);
    }
    
    const updates: Record<string, unknown> = { updated_at: Date.now() };
    if (args.title !== undefined) updates.title = args.title;
    if (args.status !== undefined) updates.status = args.status;
    if (args.sourcePosts !== undefined) updates.source_posts = args.sourcePosts;
    if (args.generationMetadata !== undefined) updates.generation_metadata = args.generationMetadata;
    
    await ctx.db.patch(document._id, updates);
    return document._id;
  },
});
